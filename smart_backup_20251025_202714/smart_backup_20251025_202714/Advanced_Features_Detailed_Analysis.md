# تحليل مفصل للميزات المتقدمة المطلوبة في تطبيق الأندرويد

يهدف هذا المستند إلى تحليل وتخطيط تنفيذ الميزات المتقدمة المطلوبة في تطبيق الأندرويد، والتي تعكس وظائف مشروع الويب المذكور. سيتم تقسيم كل ميزة إلى مكوناتها الأساسية (قاعدة البيانات، واجهة المستخدم، منطق العمل) وتحديد الخطوات اللازمة لتنفيذها.

## 1. كشوفات الحساب والتقارير المتقدمة

**المتطلبات:**
*   عرض كشوفات حساب تفصيلية.
*   ترتيب تصاعدي/تنازلي للأعمدة عند النقر على العنوان.
*   مراجعة كشف الحساب مع عمود فارغ بجوار حركة الرصيد.
*   إمكانية تحديد أن الإجمالي في صف معين يطابق كشف حساب آخر.
*   تحديد عدة أسطر بالنقر الطويل لأول مرة ثم النقر لتحديد المزيد.
*   مشاركة المحدد أو جمع عمود معين.
*   طباعة.

**التحليل والتخطيط:**

### 1.1. قاعدة البيانات (Room Entities & DAOs)
*   **`AccountStatement` Entity:** لتمثيل سجلات كشف الحساب. قد تحتاج إلى حقول مثل `transactionId`, `accountId`, `date`, `description`, `debit`, `credit`, `balance`, `reconciliationStatus`, `reconciliationNotes`.
*   **`AccountStatementDao`:** لعمليات CRUD، بالإضافة إلى استعلامات مخصصة للترتيب والتصفية.

### 1.2. واجهة المستخدم (UI)
*   **`AccountStatementListActivity`:** لعرض كشوفات الحساب في `RecyclerView`.
*   **`account_statement_list_row.xml`:** تصميم صف لكل حركة في كشف الحساب.
*   **`AccountStatementAdapter`:** محول مخصص يدعم:
    *   **الترتيب:** عند النقر على رؤوس الأعمدة (مثل التاريخ، الوصف، المدين، الدائن، الرصيد)، يتم إعادة ترتيب البيانات في `RecyclerView` تصاعديًا أو تنازليًا. يتطلب ذلك تحديث استعلام DAO أو فرز البيانات بعد جلبها.
    *   **عمود المراجعة:** إضافة `TextView` أو `CheckBox` اختياري في كل صف لعمود المراجعة. يمكن أن يكون `EditText` لإضافة ملاحظات المراجعة.
    *   **تحديد الأسطر:** استخدام `ActionMode` أو `MultiChoiceModeListener` لتحديد عدة أسطر. عند النقر الطويل على صف، يتم تفعيله، ثم يمكن النقر على صفوف أخرى لتحديدها. يجب أن يدعم المحول تغيير خلفية الصفوف المحددة.
*   **شريط الأدوات السياقي (Contextual Action Bar - CAB):** يظهر عند تحديد الأسطر، ويحتوي على خيارات مثل 

مشاركة، جمع، طباعة.

### 1.3. منطق العمل (Business Logic)
*   **`AccountStatementViewModel`:** لتوفير البيانات للواجهة وتنسيقها.
*   **`AccountStatementRepository`:** للتعامل مع منطق استرداد البيانات من DAO.
*   **منطق الترتيب:** يجب أن يتم التعامل معه إما في DAO (باستخدام `ORDER BY` ديناميكي) أو في ViewModel/Repository (بفرز القائمة بعد جلبها).
*   **منطق المزامنة:** ربط حالة المراجعة (`reconciliationStatus`) مع Firebase Firestore.

## 2. الفواتير الاحترافية (Professional Invoicing)

**المتطلبات:**
*   واجهة إدخال فواتير واسعة واحترافية.
*   مربعات تحديد لإخفاء أو إظهار بعض الضبط.
*   تذكر سعر الشراء السابق للصنف.
*   إنشاء تقرير بفوارق الأسعار لنفس الصنف من أي مورد أو من المورد نفسه.

**التحليل والتخطيط:**

### 2.1. قاعدة البيانات (Room Entities & DAOs)
*   **`Invoice` Entity:** موجودة بالفعل، قد تحتاج إلى حقول إضافية لخيارات العرض/الإخفاء.
*   **`InvoiceItem` Entity:** موجودة بالفعل، قد تحتاج إلى حقول إضافية لتخزين سعر الشراء السابق.
*   **`InvoiceDao` و `InvoiceItemDao`:** موجودة، قد تحتاج إلى استعلامات مخصصة لاسترداد سعر الشراء السابق أو تقارير فوارق الأسعار.

### 2.2. واجهة المستخدم (UI)
*   **`InvoiceDetailActivity`:** تحتاج إلى تطوير شامل لتصبح "احترافية وواسعة".
    *   **تصميم مرن:** استخدام `ConstraintLayout` أو `CoordinatorLayout` لتصميم واجهة قابلة للتخصيص.
    *   **مربعات التحديد:** إضافة `CheckBox`s أو `Switch`es للتحكم في رؤية حقول معينة (مثل حقول الضرائب، الخصومات، الشحن، إلخ). يجب أن يؤثر تغيير هذه المربعات على رؤية عناصر الواجهة المقابلة.
    *   **تذكر سعر الشراء السابق:** عند اختيار صنف، يجب جلب سعر الشراء السابق لهذا الصنف من قاعدة البيانات وعرضه للمستخدم. يمكن أن يكون هذا في `EditText` غير قابل للتحرير أو `TextView`.
    *   **إدخال الأصناف:** استخدام `RecyclerView` لإضافة وإدارة أصناف الفاتورة، مع إمكانية إضافة/حذف/تعديل كل صنف.
*   **`PriceDifferenceReportActivity`:** لإنشاء وعرض تقرير فوارق الأسعار.

### 2.3. منطق العمل (Business Logic)
*   **`InvoiceViewModel`:** لتوفير البيانات للواجهة والتعامل مع منطق الحفظ والتحديث.
*   **`InvoiceRepository`:** للتعامل مع DAO واسترداد البيانات المعقدة.
*   **منطق سعر الشراء السابق:** عند اختيار صنف، يجب على ViewModel استدعاء DAO للحصول على آخر سعر شراء لهذا الصنف من الفواتير السابقة.
*   **منطق تقرير فوارق الأسعار:** يجب على ViewModel/Repository تجميع البيانات من `InvoiceItem`s لحساب وعرض فوارق الأسعار لنفس الصنف من موردين مختلفين أو عبر فترات زمنية مختلفة.

## 3. استيراد/تصدير الأصناف والحسابات من Excel أو تصديرها

**المتطلبات:**
*   استيراد الأصناف والحسابات من Excel.
*   تصدير الأصناف والحسابات إلى Excel.

**التحليل والتخطيط:**

### 3.1. قاعدة البيانات (Room Entities & DAOs)
*   `Item` و `Account` Entities و DAOs موجودة.

### 3.2. واجهة المستخدم (UI)
*   **`ImportExportActivity`:** تم إنشاؤها بالفعل وتدعم استيراد/تصدير الأصناف والحسابات.
*   **دمج في `MainActivity`:** إضافة أزرار أو خيارات في `MainActivity` أو قائمة الإعدادات للوصول إلى `ImportExportActivity` لأنواع البيانات المختلفة (الأصناف، الحسابات).

### 3.3. منطق العمل (Business Logic)
*   **`ExcelUtil`:** تم إنشاؤه بالفعل للتعامل مع قراءة وكتابة ملفات Excel.
*   **`ImportExportActivity`:** تحتوي على منطق استدعاء `ExcelUtil` ومعالجة البيانات المستوردة/المصدرة.
*   **التحقق من البيانات:** يجب إضافة منطق للتحقق من صحة البيانات المستوردة قبل حفظها في قاعدة البيانات.

## 4. استيراد الفاتورة من الباركود أو تصديرها

**المتطلبات:**
*   استيراد الفاتورة من الباركود (مربع أو عادي) وتعبئة البيانات.
*   تصدير الفاتورة إلى باركود (مربع أو عادي).
*   المستخدم يطابق الكمية ويحفظ.

**التحليل والتخطيط:**

### 4.1. قاعدة البيانات (Room Entities & DAOs)
*   `Invoice` و `InvoiceItem` Entities و DAOs موجودة.

### 4.2. واجهة المستخدم (UI)
*   **`InvoiceDetailActivity`:**
    *   **زر استيراد الباركود:** إضافة زر في واجهة إدخال الفاتورة لتشغيل ماسح الباركود.
    *   **عرض البيانات المستوردة:** بعد مسح الباركود، يتم عرض البيانات المستوردة في حقول الفاتورة، مع تمييز حقل الكمية ليقوم المستخدم بمطابقته.
    *   **زر تصدير الباركود:** إضافة زر لتوليد وعرض باركود (QR Code) للفاتورة الحالية.
*   **`BarcodeScannerActivity`:** نشاط جديد لتشغيل كاميرا الجهاز ومسح الباركود.
*   **`BarcodeGeneratorUtil`:** أداة مساعدة لتوليد صور الباركود (QR Code).

### 4.3. منطق العمل (Business Logic)
*   **`BarcodeScanner` library:** استخدام مكتبة خارجية (مثل ZXing) لتنفيذ وظيفة مسح الباركود.
*   **`BarcodeGenerator` library:** استخدام مكتبة لتوليد صور الباركود.
*   **منطق الاستيراد:** عند مسح باركود، يتم تحليل البيانات المستخرجة (التي يجب أن تكون بتنسيق JSON أو XML أو نص محدد يمثل الفاتورة) وتعبئة حقول `InvoiceDetailActivity`.
*   **منطق التصدير:** عند النقر على زر التصدير، يتم تجميع بيانات الفاتورة الحالية وتشفيرها في تنسيق باركود (QR Code) وعرضها للمستخدم أو حفظها كصورة.

## 5. مزامنة جهات الاتصال مع أي حساب مسجل في التطبيق (نفس الإيميل)

**المتطلبات:**
*   مزامنة جهات الاتصال مع أي حساب مسجل في التطبيق باستخدام نفس البريد الإلكتروني.

**التحليل والتخطيط:**

### 5.1. قاعدة البيانات (Room Entities & DAOs)
*   **`Contact` Entity:** لتمثيل جهات الاتصال المحلية التي تم مزامنتها. قد تحتاج إلى حقول مثل `name`, `email`, `phone`, `userId` (إذا كان المستخدم مسجلاً في التطبيق).
*   **`ContactDao`:** لعمليات CRUD على جهات الاتصال.

### 5.2. واجهة المستخدم (UI)
*   **`SettingsActivity` أو `SyncSettingsFragment`:** إضافة خيار في الإعدادات لتفعيل/تعطيل مزامنة جهات الاتصال.
*   **`ContactListActivity`:** لعرض جهات الاتصال المزامنة، مع إمكانية عرض حالة المزامنة (مسجل في التطبيق أم لا).

### 5.3. منطق العمل (Business Logic)
*   **`ContactSyncService`:** خدمة تعمل في الخلفية لمزامنة جهات الاتصال.
*   **`ContentResolver`:** لاسترداد جهات الاتصال من الجهاز.
*   **Firebase Firestore / Backend API:** للتحقق مما إذا كانت عناوين البريد الإلكتروني لجهات الاتصال موجودة في قاعدة بيانات المستخدمين المسجلين في التطبيق.
*   **منطق المزامنة:**
    1.  قراءة جهات الاتصال من الجهاز.
    2.  استخراج عناوين البريد الإلكتروني.
    3.  التحقق من هذه العناوين مقابل قائمة المستخدمين المسجلين في التطبيق (عبر Firebase أو API).
    4.  تحديث قاعدة بيانات Room المحلية (`Contact` Entity) بحالة المزامنة.
    5.  إرسال إشعارات للمستخدمين إذا تم العثور على جهات اتصال مسجلة حديثًا.

## 6. إنشاء إشعارات عند القيام بأي عملية أو معاملة أو رسالة أو طلب للحساب

**المتطلبات:**
*   إشعارات فورية (Push Notifications) عند القيام بأي عملية، معاملة، رسالة، أو طلب للحساب.
*   ظهور الإشعار حتى لو كان التطبيق مغلقًا.

**التحليل والتخطيط:**

### 6.1. قاعدة البيانات (Room Entities & DAOs)
*   `Notification` Entity و `NotificationDao` موجودة بالفعل.

### 6.2. واجهة المستخدم (UI)
*   **`NotificationListActivity`:** موجودة لعرض الإشعارات.
*   **`NotificationDetailActivity`:** موجودة لعرض تفاصيل الإشعار.

### 6.3. منطق العمل (Business Logic)
*   **Firebase Cloud Messaging (FCM):** الأداة الأساسية لإرسال واستقبال الإشعارات الفورية.
*   **`FirebaseMessagingService`:** خدمة مخصصة في التطبيق لاستقبال رسائل FCM ومعالجتها.
*   **الخادم الخلفي (Backend Server):** يجب أن يقوم الخادم بإرسال رسائل FCM إلى الأجهزة عند حدوث أي من الأحداث المذكورة (عملية، معاملة، رسالة، طلب حساب).
*   **منطق الإشعارات:**
    1.  عند حدوث حدث (مثل إنشاء فاتورة، استلام رسالة، طلب حساب)، يقوم الخادم بإرسال رسالة FCM إلى الجهاز المستهدف.
    2.  تستقبل `FirebaseMessagingService` الرسالة.
    3.  إذا كان التطبيق في الخلفية أو مغلقًا، يتم عرض إشعار في شريط الإشعارات.
    4.  إذا كان التطبيق في المقدمة، يمكن عرض الإشعار داخل التطبيق أو تحديث الواجهة مباشرة.
    5.  يتم حفظ الإشعار في قاعدة بيانات Room المحلية (`Notification` Entity) لعرضه لاحقًا في `NotificationListActivity`.

## 7. نظام صلاحيات واسع جداً للمسؤولين

**المتطلبات:**
*   نظام صلاحيات واسع جداً للمسؤولين.
*   سجل تعديلات وحذف المسؤولين.

**التحليل والتخطيط:**

### 7.1. قاعدة البيانات (Room Entities & DAOs)
*   **`Role` Entity و `RoleDao`:** موجودة.
*   **`Permission` Entity و `PermissionDao`:** موجودة.
*   **`UserRole` Entity و `UserRoleDao`:** موجودة لربط المستخدمين بالأدوار.
*   **`UserPermission` Entity و `UserPermissionDao`:** موجودة لربط المستخدمين بالصلاحيات المباشرة (إذا لزم الأمر).
*   **`AuditLog` Entity و `AuditLogDao`:** موجودة لتسجيل التعديلات والحذف.

### 7.2. واجهة المستخدم (UI)
*   **`RoleListActivity` و `RoleDetailActivity`:** موجودة لإدارة الأدوار والصلاحيات.
*   **`AdminUserListActivity` و `AdminUserDetailActivity`:** موجودة لإدارة المستخدمين وتعيين الأدوار لهم.
*   **`AuditLogActivity`:** نشاط جديد لعرض سجل التعديلات والحذف.
*   **`AuditLogAdapter` و `audit_log_row.xml`:** لعرض سجلات التدقيق.

### 7.3. منطق العمل (Business Logic)
*   **`PermissionChecker` Utility:** فئة مساعدة للتحقق مما إذا كان المستخدم يمتلك صلاحية معينة.
*   **منطق الصلاحيات:**
    1.  عند محاولة المستخدم تنفيذ إجراء معين، يتم استدعاء `PermissionChecker` للتحقق من صلاحياته.
    2.  تعتمد الصلاحيات على الأدوار المخصصة للمستخدم، ويمكن أن تكون هناك صلاحيات مباشرة للمستخدم.
    3.  يجب أن يتم تطبيق التحقق من الصلاحيات في جميع نقاط الوصول الحساسة في التطبيق (مثل حفظ فاتورة، حذف مستخدم، تعديل دور).
*   **منطق سجل التدقيق:**
    1.  عند حدوث أي عملية حساسة (مثل إنشاء/تعديل/حذف مستخدم، دور، فاتورة)، يتم تسجيل تفاصيل العملية (من قام بها، متى، وماذا تم) في `AuditLog` Entity.
    2.  يمكن عرض هذا السجل للمسؤولين لمراجعة الأنشطة.

## 8. الكؤوس المرتبطة بي (Trophies)

**المتطلبات:**
*   صفحات الكؤوس المرتبطة بي.

**التحليل والتخطيط:**

### 8.1. قاعدة البيانات (Room Entities & DAOs)
*   **`Trophy` Entity و `TrophyDao`:** موجودة.
*   **`UserTrophy` Entity:** لربط المستخدمين بالكؤوس التي حصلوا عليها. قد تحتاج إلى حقول مثل `userId`, `trophyId`, `achievedDate`.
*   **`UserTrophyDao`:** لعمليات CRUD على كؤوس المستخدمين.

### 8.2. واجهة المستخدم (UI)
*   **`TrophyListActivity`:** موجودة لعرض الكؤوس.
*   **`TrophyDetailActivity`:** موجودة لعرض تفاصيل الكأس.
*   **`UserTrophyListActivity`:** نشاط جديد لعرض الكؤوس التي حصل عليها المستخدم الحالي.
*   **`UserTrophyAdapter` و `user_trophy_list_row.xml`:** لعرض كؤوس المستخدم.

### 8.3. منطق العمل (Business Logic)
*   **`TrophyManager`:** فئة مساعدة لإدارة منح الكؤوس.
*   **منطق منح الكؤوس:** عند تحقيق المستخدم لشروط معينة (مثل الوصول إلى عدد معين من النقاط، إتمام عدد معين من المعاملات)، يتم منح الكأس له وتسجيله في `UserTrophy` Entity.

## 9. صفحات إضافة أصدقاء

**المتطلبات:**
*   صفحات إضافة أي أصدقاء.

**التحليل والتخطيط:**

### 9.1. قاعدة البيانات (Room Entities & DAOs)
*   **`Friendship` Entity:** لتمثيل علاقات الصداقة بين المستخدمين. قد تحتاج إلى حقول مثل `userId1`, `userId2`, `status` (معلق، مقبول، مرفوض).
*   **`FriendshipDao`:** لعمليات CRUD على علاقات الصداقة.

### 9.2. واجهة المستخدم (UI)
*   **`FriendListActivity`:** نشاط جديد لعرض قائمة الأصدقاء وطلبات الصداقة.
*   **`FriendRequestActivity`:** نشاط جديد للبحث عن مستخدمين وإرسال طلبات صداقة.
*   **`FriendAdapter` و `friend_list_row.xml`:** لعرض الأصدقاء.

### 9.3. منطق العمل (Business Logic)
*   **`FriendshipManager`:** فئة مساعدة لإدارة علاقات الصداقة.
*   **منطق طلبات الصداقة:**
    1.  يمكن للمستخدم البحث عن مستخدمين آخرين (عبر البريد الإلكتروني أو اسم المستخدم).
    2.  إرسال طلب صداقة يسجل في `Friendship` Entity بحالة "معلق".
    3.  يتلقى المستخدم الآخر إشعارًا بطلب الصداقة.
    4.  يمكن للمستخدم الآخر قبول أو رفض الطلب، مما يغير حالة `Friendship` Entity.
*   **مزامنة جهات الاتصال:** يمكن دمج هذه الميزة مع مزامنة جهات الاتصال المقترحة سابقًا لاقتراح أصدقاء محتملين من جهات الاتصال.

## 10. سجل تعديلات وحذف المسؤولين

**المتطلبات:**
*   سجل تعديلات وحذف المسؤولين.

**التحليل والتخطيط:**

### 10.1. قاعدة البيانات (Room Entities & DAOs)
*   **`AuditLog` Entity و `AuditLogDao`:** موجودة بالفعل وتغطي هذا المتطلب.

### 10.2. واجهة المستخدم (UI)
*   **`AuditLogActivity`:** نشاط جديد لعرض سجل التدقيق.
*   **`AuditLogAdapter` و `audit_log_row.xml`:** لعرض سجلات التدقيق.

### 10.3. منطق العمل (Business Logic)
*   **`AuditLogger` Utility:** فئة مساعدة لتسجيل الأحداث في `AuditLog` Entity.
*   **التكامل:** يجب استدعاء `AuditLogger` في كل مكان يتم فيه إجراء تعديل أو حذف بواسطة مسؤول (مثل تعديل دور، حذف مستخدم، تعديل فاتورة).
